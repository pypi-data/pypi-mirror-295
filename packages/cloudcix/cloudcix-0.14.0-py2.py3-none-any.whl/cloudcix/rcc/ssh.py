# Methods for ensuring data reaches a remote host in its entirity
# stdlib
import ipaddress
import socket
from collections import deque
from typing import Deque, Tuple, Union
# libs
from paramiko import AutoAddPolicy, SSHClient, SSHException
# local
from cloudcix.rcc.exceptions import CouldNotConnectException

IPAddress = Union[ipaddress.IPv4Address, ipaddress.IPv6Address]


def comms_ssh(host_ip: str, payload: str, username: str = 'administrator', timeout: int = 4) -> Tuple[int, str, str]:
    """
    Run a command on a remote host over an SSH connection
    Raises `CouldNotConnectException` if an SSH connection cannot be established
    :param host_ip: The IP address where the command should be run
    :param payload: The shell commands to run on the remote host
    :param username: The user that will run the commands on the remote host
    :param timeout: How long the client can attempt to connect to the remote host
    :return: A three-tuple containing the Linux exit code, standard output and standard error generated by the payload
    """
    try:
        ip = ipaddress.ip_address(host_ip)
    except ValueError as e:
        err = 'Error: Could not parse `host_ip`\n' + str(e)
        raise CouldNotConnectException(err)

    client, err = get_client(ip, username, timeout)
    if err:
        raise CouldNotConnectException(err)

    exit_code, out, err = _deploy_paramiko(client, payload)
    client.close()
    return exit_code, out, err


def get_client(ip: IPAddress, username: str, timeout: int) -> SSHClient:
    """
    Obtain a paramiko.SSHClient connected to the given `ip`
    :param ip: An IPAddress to connect to
    :param username: The remote user to login as
    :param timeout: How long the client can attempt to connect to the remote host
    :return: An ssh client
    """
    client = SSHClient()
    client.set_missing_host_key_policy(AutoAddPolicy())
    if 6 == ip.version:
        proto = socket.AF_INET6
    else:
        proto = socket.AF_INET
    sock = socket.socket(proto, socket.SOCK_STREAM)
    try:
        # Try connecting to the host using SSH keys
        sock.settimeout(timeout)
        sock.connect((str(ip), 22))
        client.connect(
            hostname=str(ip),
            username=username,
            timeout=timeout,
            sock=sock,
        )
    except (SSHException, OSError) as e:
        return '', str(e)
    return client, ''


def _deploy_paramiko(client: SSHClient, payload: str) -> Tuple[int, str, str]:
    """
    Deploy the given `payload` to the SSH host accessible via the supplied `client`
    :param client: A paramiko.Client instance that is connected to the host
    :param payload: The command(s) to run on the host
    :return: The Linux exit code, stdout and stderr of running the payload on the remote host
    """

    _, stdout, stderr = client.exec_command(payload)

    # Read from stdout and stderr until the connection is closed
    channel = stdout.channel
    output_fragments: Deque[str] = deque()
    error_fragments: Deque[str] = deque()
    while True:
        # Check the status of the connection, and read any remaining output
        closed = channel.closed
        while channel.recv_ready():
            output_fragments.append(stdout.read().decode())  # Read the entirety of stdout

        while channel.recv_stderr_ready():
            error_fragments.append(stderr.read().decode())  # Read the entirety of stderr

        if closed:
            exit_code = channel.recv_exit_status()
            break

    output = ''.join(output_fragments)
    error = ''.join(error_fragments)

    return exit_code, output, error
