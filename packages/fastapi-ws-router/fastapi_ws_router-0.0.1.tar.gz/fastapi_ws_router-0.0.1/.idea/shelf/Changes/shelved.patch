Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from types import GenericAlias\nfrom typing import (\n    Literal,\n    Callable,\n    Dict,\n    Union,\n    Annotated,\n    Optional,\n    Sequence,\n    Tuple,\n)\n\nfrom fastapi import FastAPI, Depends, Header, HTTPException\nfrom fastapi.routing import APIRoute, get_websocket_app\nfrom pydantic import BaseModel, TypeAdapter, Field, ValidationError\nfrom starlette._exception_handler import wrap_app_handling_exceptions\nfrom starlette.requests import Request\nfrom starlette.responses import Response\nfrom starlette.routing import websocket_session, WebSocketRoute, Match\nfrom starlette.types import Scope, Receive, Send\nfrom starlette.websockets import WebSocket\n\napp = FastAPI()\n\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n\n\n@app.post(\"/hello/{name}\")\nasync def say_hello(name: str):\n    return {\"message\": f\"Hello {name}\"}\n\n\n@app.websocket(\"/ws\")\nasync def websocket(websocket: WebSocket):\n    await websocket.accept()\n    await websocket.send_json({\"msg\": \"Hello WebSocket\"})\n    await websocket.close()\n\n\n# class WSRoute(WebSocketRoute):\nclass WSRoute(APIRoute):\n    _adapter: TypeAdapter\n\n    def __init__(\n        self,\n        path: str,\n        discriminator: str,\n        name: Optional[str] = None,\n        dependencies: Sequence[Depends] | None = None,\n        include_in_schema: bool = True,\n        dependency_overrides_provider: Optional[Callable] = None,\n    ):\n        super().__init__(\n            path,\n            self,\n            methods=[\"POST\"],\n            name=name,\n            dependencies=dependencies,\n            dependency_overrides_provider=dependency_overrides_provider,\n            include_in_schema=include_in_schema,\n        )\n        self.discriminator = discriminator\n        self.mapping: Dict[type, Callable] = {}\n        self._adapter = None\n        self.app = websocket_session(\n            get_websocket_app(\n                dependant=self.dependant,\n                dependency_overrides_provider=dependency_overrides_provider,\n                embed_body_fields=self._embed_body_fields,\n            )\n        )\n        # self.__call__ = self.__call__internal__\n\n    def matches(self, scope: Scope) -> Tuple[Match, Scope]:\n        return WebSocketRoute.matches(self, scope)\n\n    # def url_path_for(self, name: str, /, **path_params: Any) -> URLPath:\n    #     return WebSocketRoute.url_path_for(self, name, **path_params)\n\n    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:\n        session = WebSocket(scope, receive=receive, send=send)\n\n        async def app(scope: Scope, receive: Receive, send: Send) -> None:\n            await self.__call(session)\n\n        await wrap_app_handling_exceptions(app, session)(scope, receive, send)\n\n    # This is how we fake the endpoint signature for the api documentation.\n    # The actual communication is being handled in the `handle` method.\n    async def __call__(self): ...\n\n    async def _on_connect(self, websocket: WebSocket) -> None:\n        \"\"\"Override to handle an incoming websocket connection\"\"\"\n        await websocket.accept()\n\n    # async def on_receive(self, websocket: WebSocket, data: typing.Any) -> None:\n    #     \"\"\"Override to handle an incoming websocket message\"\"\"\n    #\n    # async def on_disconnect(self, websocket: WebSocket, close_code: int) -> None:\n    #     \"\"\"Override to handle a disconnecting websocket\"\"\"\n\n    def _build_adapter(self) -> TypeAdapter:\n        models = GenericAlias(Union, tuple(self.mapping.keys()))\n        AnnotatedModels = Annotated[models, Field(discriminator=self.discriminator)]\n        return TypeAdapter(AnnotatedModels)\n\n    async def __call(self, websocket: WebSocket):\n        if not self._adapter:\n            self._adapter = self._build_adapter()\n\n        await self._on_connect(websocket)\n\n        message = await websocket.receive_text()\n        try:\n            validated = self._adapter.validate_json(message)\n        except ValidationError as e:\n            await self._fallback(websocket, message, e)\n            return\n\n        handler = self.mapping[validated.__class__]\n        await handler(validated, websocket)\n\n        # await websocket.send_json({\"msg\": \"Hello WebSocket\"})\n        await websocket.close()\n\n    def on_connect(self, func):\n        self._on_connect = func\n        return func\n\n    def receive(self, model: type):\n        def decorator(func):\n            self.mapping[model] = func\n            return func\n\n        return decorator\n\n    def fallback(self, func):\n        self._fallback = func\n        return func\n\n\nclass UserMessage(BaseModel):\n    message_type: Literal[\"user\"]\n    user_id: int\n    user_name: str\n\n\nclass PostMessage(BaseModel):\n    message_type: Literal[\"post\"]\n    post_id: int\n    post_content: str\n\n\nasync def headerauth(x_token: Optional[str] = Header(None)):\n    if x_token == \"fail\":\n        raise HTTPException(status_code=400, detail=\"X-Token header invalid\")\n\n\nrouter = WSRoute(\n    \"/ws2\",\n    discriminator=\"message_type\",\n    dependencies=[Depends(headerauth)],\n)\napp.routes.append(router)\n\n\nasync def app2(req: Request) -> Response: ...\n\n\napp.add_api_route(\"/static\", app2, methods=[\"POST\"], name=\"static\")\n\n\n@router.on_connect\nasync def on_connect(websocket: WebSocket):\n    if \"Fail\" in websocket.scope[\"subprotocols\"]:\n        await websocket.close()\n    else:\n        await websocket.accept()\n\n\n@router.fallback\nasync def fallback(websocket: WebSocket, message: str, error: ValidationError):\n    await websocket.send_text(\"Invalid message type\")\n\n\n@router.receive(UserMessage)\nasync def get_user_message(message: UserMessage, websocket: WebSocket):\n    await websocket.send_json({\"model\": \"UserMessage\"})\n\n\n@router.receive(PostMessage)\nasync def get_post_message(message: PostMessage, websocket: WebSocket):\n    await websocket.send_json({\"model\": \"PostMessage\"})\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision b21a308dfd47b5407010c9df5d989a79bbfd3458)
+++ b/main.py	(date 1725696716425)
@@ -1,3 +1,4 @@
+from enum import Enum
 from types import GenericAlias
 from typing import (
     Literal,
@@ -8,22 +9,37 @@
     Optional,
     Sequence,
     Tuple,
+    List,
+    Any,
 )
+from typing_extensions import Doc
 
-from fastapi import FastAPI, Depends, Header, HTTPException
-from fastapi.routing import APIRoute, get_websocket_app
+from fastapi import FastAPI, Depends, Header, HTTPException, params
+from fastapi.routing import APIRoute, get_websocket_app, APIRouter
 from pydantic import BaseModel, TypeAdapter, Field, ValidationError
 from starlette._exception_handler import wrap_app_handling_exceptions
 from starlette.requests import Request
 from starlette.responses import Response
 from starlette.routing import websocket_session, WebSocketRoute, Match
-from starlette.types import Scope, Receive, Send
+from starlette.types import Scope, Receive, Send, Lifespan
 from starlette.websockets import WebSocket
 
 app = FastAPI()
 
 
-@app.get("/")
+class UserMessage(BaseModel):
+    message_type: Literal["user"]
+    user_id: int
+    user_name: str
+
+
+class PostMessage(BaseModel):
+    message_type: Literal["post"]
+    post_id: int
+    post_content: str
+
+
+@app.get("/", response_model=Union[UserMessage, PostMessage])
 async def root():
     return {"message": "Hello World"}
 
@@ -40,18 +56,18 @@
     await websocket.close()
 
 
-# class WSRoute(WebSocketRoute):
 class WSRoute(APIRoute):
     _adapter: TypeAdapter
 
     def __init__(
         self,
         path: str,
-        discriminator: str,
+        discriminator: str = None,
         name: Optional[str] = None,
         dependencies: Sequence[Depends] | None = None,
         include_in_schema: bool = True,
         dependency_overrides_provider: Optional[Callable] = None,
+        **kwargs,
     ):
         super().__init__(
             path,
@@ -63,7 +79,6 @@
             include_in_schema=include_in_schema,
         )
         self.discriminator = discriminator
-        self.mapping: Dict[type, Callable] = {}
         self._adapter = None
         self.app = websocket_session(
             get_websocket_app(
@@ -126,6 +141,144 @@
         # await websocket.send_json({"msg": "Hello WebSocket"})
         await websocket.close()
 
+
+class WSRouter(APIRouter):
+    def __init__(
+        self,
+        *,
+        discriminator: Annotated[str, Doc("The field name to use as a discriminator.")],
+        prefix: Annotated[str, Doc("An optional path prefix for the router.")] = "",
+        tags: Annotated[
+            Optional[List[Union[str, Enum]]],
+            Doc(
+                """
+                A list of tags to be applied to all the *path operations* in this
+                router.
+
+                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
+
+                Read more about it in the
+                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
+                """
+            ),
+        ] = None,
+        dependencies: Annotated[
+            Optional[Sequence[params.Depends]],
+            Doc(
+                """
+                A list of dependencies (using `Depends()`) to be applied to all the
+                *path operations* in this router.
+
+                Read more about it in the
+                [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
+                """
+            ),
+        ] = None,
+        dependency_overrides_provider: Annotated[
+            Optional[Any],
+            Doc(
+                """
+                Only used internally by FastAPI to handle dependency overrides.
+
+                You shouldn't need to use it. It normally points to the `FastAPI` app
+                object.
+                """
+            ),
+        ] = None,
+        on_startup: Annotated[
+            Optional[Sequence[Callable[[], Any]]],
+            Doc(
+                """
+                A list of startup event handler functions.
+
+                You should instead use the `lifespan` handlers.
+
+                Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
+                """
+            ),
+        ] = None,
+        on_shutdown: Annotated[
+            Optional[Sequence[Callable[[], Any]]],
+            Doc(
+                """
+                A list of shutdown event handler functions.
+
+                You should instead use the `lifespan` handlers.
+
+                Read more in the
+                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
+                """
+            ),
+        ] = None,
+        # the generic to Lifespan[AppType] is the type of the top level application
+        # which the router cannot know statically, so we use typing.Any
+        lifespan: Annotated[
+            Optional[Lifespan[Any]],
+            Doc(
+                """
+                A `Lifespan` context manager handler. This replaces `startup` and
+                `shutdown` functions with a single context manager.
+
+                Read more in the
+                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
+                """
+            ),
+        ] = None,
+        deprecated: Annotated[
+            Optional[bool],
+            Doc(
+                """
+                Mark all *path operations* in this router as deprecated.
+
+                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
+
+                Read more about it in the
+                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
+                """
+            ),
+        ] = None,
+        include_in_schema: Annotated[
+            bool,
+            Doc(
+                """
+                To include (or not) all the *path operations* in this router in the
+                generated OpenAPI.
+
+                This affects the generated OpenAPI (e.g. visible at `/docs`).
+
+                Read more about it in the
+                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).
+                """
+            ),
+        ] = True,
+    ) -> None:
+        super().__init__(
+            on_startup=on_startup,
+            on_shutdown=on_shutdown,
+            lifespan=lifespan,
+            prefix=prefix,
+            route_class=WSRoute,
+            tags=tags,
+            dependencies=dependencies,
+            dependency_overrides_provider=dependency_overrides_provider,
+            deprecated=deprecated,
+            include_in_schema=include_in_schema,
+        )
+        self.discriminator = discriminator
+        self.mapping: Dict[type, Callable] = {}
+        # self.add_api_route(
+        #     path="",
+        #     route_class_override=WSRoute,
+        #     endpoint=WSRoute(
+        #         path=self.prefix, endpoint=None, discriminator=discriminator
+        #     ),
+        #     methods=["POST"],
+        # )
+        self.routes.append(
+            WSRoute(path="", discriminator=discriminator),
+            # WSRoute(endpoint=self.prefix, discriminator=discriminator),
+        )
+
     def on_connect(self, func):
         self._on_connect = func
         return func
@@ -142,35 +295,28 @@
         return func
 
 
-class UserMessage(BaseModel):
-    message_type: Literal["user"]
-    user_id: int
-    user_name: str
-
-
-class PostMessage(BaseModel):
-    message_type: Literal["post"]
-    post_id: int
-    post_content: str
-
-
 async def headerauth(x_token: Optional[str] = Header(None)):
     if x_token == "fail":
         raise HTTPException(status_code=400, detail="X-Token header invalid")
 
 
-router = WSRoute(
-    "/ws2",
+# router = WSRoute(
+#     "/ws3",
+#     discriminator="message_type",
+#     dependencies=[Depends(headerauth)],
+# )
+# app.routes.append(router)
+
+router = WSRouter(
     discriminator="message_type",
     dependencies=[Depends(headerauth)],
 )
-app.routes.append(router)
 
 
 async def app2(req: Request) -> Response: ...
 
 
-app.add_api_route("/static", app2, methods=["POST"], name="static")
+# app.add_api_route("/static", app2, methods=["POST"], name="static")
 
 
 @router.on_connect
@@ -194,3 +340,6 @@
 @router.receive(PostMessage)
 async def get_post_message(message: PostMessage, websocket: WebSocket):
     await websocket.send_json({"model": "PostMessage"})
+
+
+app.include_router(router, prefix="/ws2")
