{
  "en": {
    "no_such_attribute": "Object has no attribute '%{attribute}'",
    "json_invalid": "Invalid JSON: %{error}",
    "json_type": "JSON input should be string, bytes or bytearray",
    "recursion_loop": "Recursion error - cyclic reference detected",
    "missing": "%{property} is required",
    "frozen_field": "%{property} is frozen",
    "frozen_instance": "Instance is frozen",
    "extra_forbidden": "Extra inputs are not permitted",
    "invalid_key": "%{property} should be strings",
    "get_attribute_error": "Error extracting attribute: %{error}",
    "model_type": "%{property} should be a valid dictionary or instance of %{class_name}",
    "model_attributes_type": "%{property} should be a valid dictionary or object to extract fields from",
    "dataclass_type": "%{property} should be an object",
    "dataclass_exact_type": "%{property} should be an instance of %{class_name}",
    "none_required": "%{property} should be null",
    "greater_than": "%{property} should be greater than %{gt}",
    "greater_than_equal": "%{property} should be greater than or equal to %{ge}",
    "less_than": "%{property} should be less than %{lt}",
    "less_than_equal": "%{property} should be less than or equal to %{le}",
    "multiple_of": "%{property} should be a multiple of %{multiple_of}",
    "finite_number": "%{property} should be a finite number",
    "too_short": "%{property} should have at least %{min_length} item(s) not %{actual_length}",
    "too_long": "%{property} should have at most %{max_length} item(s) not %{actual_length}",
    "iterable_type": "%{property} should be iterable",
    "iteration_error": "Error iterating over object, error: %{error}",
    "string_type": "%{property} should be a valid string",
    "string_sub_type": "%{property} should be a string, not an instance of a subclass of str",
    "string_unicode": "%{property} should be a valid string, unable to parse raw data as a unicode string",
    "string_too_short": "%{property} should have at least %{min_length} characters",
    "string_too_long": "%{property} should have at most %{max_length} characters",
    "string_pattern_mismatch": "%{property} should match pattern '%{pattern}'",
    "enum": "%{property} should be %{expected}",
    "dict_type": "%{property} should be a valid dictionary",
    "mapping_type": "%{property} should be a valid mapping, error: %{error}",
    "list_type": "%{property} should be a valid list",
    "tuple_type": "%{property} should be a valid tuple",
    "set_type": "%{property} should be a valid set",
    "bool_type": "%{property} should be a valid boolean",
    "bool_parsing": "%{property} should be a valid boolean, umable to interpret input",
    "int_type": "%{property} should be a valid integer",
    "int_parsing": "%{property} should be a valid integer, unable to parse string as an integer",
    "int_parsing_size": "%{property} should be a valid integer, got a number with a fractional part",
    "int_from_float": "Unable to parse input string as an integer, exceeded maximum size",
    "float_type": "%{property} should be a valid float number",
    "float_parsing": "%{property} should be a valid number, unable to parse string as a number",
    "bytes_type": "%{property} should be a valid bytes",
    "bytes_too_short": "Data should have at least %{min_length} bytes",
    "bytes_too_long": "Data should have at most %{max_length} bytes",
    "value_error": "Value error, %{error}",
    "assertion_error": "Assertion failed, %{error}",
    "literal_error": "%{property} should be %{expected}",
    "date_type": "%{property} should be a valid date",
    "date_parsing": "%{property} should be a valid date in the format YYYY-MM-DD, %{error}",
    "date_from_datetime_parsing": "%{property} should be a valid date or datetime, %{error}",
    "date_from_datetime_inexact": "Datetimes provided to dates should have zero time - e.g. be exact dates",
    "date_past": "%{property} should be in the past",
    "date_future": "%{property} should be in the future",
    "time_type": "%{property} should be a valid time",
    "time_parsing": "%{property} should be in a valid time format, %{error}",
    "datetime_type": "%{property} should be a valid datetime",
    "datetime_parsing": "%{property} should be a valid datetime, %{error}",
    "datetime_object_invalid": "Invalid datetime object, got %{error}",
    "datetime_past": "%{property} should be in the past",
    "datetime_future": "%{property} should be in the future",
    "timezone_naive": "%{property} should not have timezone info",
    "timezone_aware": "%{property} should have timezone info",
    "timezone_offset": "Timezone offset of %{tz_expected} required, got %{tz_actual}",
    "time_delta_type": "%{property} should be a valid duration",
    "time_delta_parsing": "%{property} should be a valid duration, %{error}",
    "frozen_set_type": "%{property} should be a valid array",
    "is_instance_of": "%{property} should be an instance of %{class}",
    "is_subclass_of": "%{property} should be a subclass of %{class}",
    "callable_type": "%{property} should be callable",
    "union_tag_invalid": "%{property} tag '%{tag}' found using %{discriminator} does not match any of the expected tags: %{expected_tags}",
    "union_tag_not_found": "Unable to extract tag using discriminator %{discriminator}",
    "arguments_type": "Arguments must be an array or an object",
    "missing_argument": "missing required argument",
    "unexpected_keyword_argument": "Unexpected keyword argument",
    "missing_keyword_only_argument": "missing required keyword only argument",
    "unexpected_positional_argument": "Unexpected positional argument",
    "missing_positional_only_argument": "Missing required positional only argument",
    "multiple_argument_values": "Got multiple values for argument",
    "url_type": "%{property} URL should be a string or URL",
    "url_parsing": "%{property} should be a valid URL, %{error}",
    "url_syntax_violation": "%{property} violated strict URL syntax rules, %{error}",
    "url_too_long": "%{property} URL should have at most %{max_length} characters",
    "url_scheme": "%{property} URL scheme should be %{expected_schemes}",
    "uuid_type": "%{property} should be a string, bytes or UUID object",
    "uuid_parsing": "%{property} should be a valid UUID, %{error}",
    "uuid_version": "%{property} should be UUID version %{expected_version}",
    "decimal_type": "%{property} should be an integer, float, string or Decimal object",
    "decimal_parsing": "%{property} should be a valid decimal",
    "decimal_max_digits": "%{property} should have no more than %{max_digits} digits in total",
    "decimal_max_places": "%{property} should have no more than %{decimal_places} decimal places",
    "decimal_whole_digits": "%{property} should have no more than %{whole_digits} digits before the decimal point",

    "invalid_value_error": "%{property} is invalid",
    "value_error.country_code.invalid": "Country code is invalid.",
    "value_error.country_code_phone_number.missing": "Missing country code or phone number.",
    "value_error.email.not_exist": "This email does not exist.",
    "value_error.email.duplicated": "This email is already registered.",
    "value_error.enum_query.invalid": "Invalid enum query.",
    "value_error.topic.invalid": "Invalid topics.",
    "value_error.username.duplicated": "This username is already registered.",
    "value_error.media": {
      "not_exist": "Media not found.",
      "duplicated": "Media is already in used.",
      "not_supported_format": "This format is not supported."
    },
    "value_error.phone_number": {
      "not_exist": "This phone number does not exist.",
      "duplicated": "This phone number is already registered.",
      "invalid": "Phone number is invalid.",
      "wrong_format": "Only digits 0-9 allowed."
    },
    "value_error.auth.missing_credentials": "Missing one of the required credentials: %{constraint1}, %{constraint2}, %{constraint3} or %{constraint4}.",
    "value_error.latlng.missing": "Latitude and longitude are required.",
    "value_error.file_size.too_large": "This format is too large.",
    "value_error.hotspot_media.not_video_type": "Media type must be video.",
    "value_error.password.duplicated": "Your new password as same as your old password."
  }
}
