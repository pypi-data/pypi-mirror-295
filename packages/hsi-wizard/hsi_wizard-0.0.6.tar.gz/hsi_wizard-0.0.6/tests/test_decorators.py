# pytest functions for decorators

# Generated by CodiumAI

from wizard._utils.decorators import check_path
from wizard._utils.decorators import track_execution_time
from wizard._utils.decorators import check_limits
from wizard._utils.decorators import add_method


import time
import pytest
import numpy as np

VALID_PATH = '.'


class TestCheckPath:

    #  Function called with valid path
    def test_valid_path(self):
        @check_path
        def dummy_func(path):
            return True

        assert dummy_func(VALID_PATH) == True

    #  Function called with valid path and additional arguments
    def test_valid_path_with_args(self):
        @check_path
        def dummy_func(path, arg1, arg2):
            return True

        assert dummy_func(VALID_PATH, 'arg1', 'arg2') == True

    #  Function called with valid path and keyword argument
    def test_valid_path_with_kwarg(self):
        @check_path
        def dummy_func(path, kwarg=None):
            return True

        assert dummy_func(VALID_PATH, kwarg='value') == True

    #  Function called with valid path and multiple keyword arguments
    def test_valid_path_with_multiple_kwargs(self):
        @check_path
        def dummy_func(path, kwarg1=None, kwarg2=None):
            return True

        assert dummy_func(VALID_PATH, kwarg1='value1', kwarg2='value2') == True

    #  Function called with empty string path
    def test_empty_string_path(self):
        @check_path
        def dummy_func(path):
            return True

        with pytest.raises(ValueError):
            dummy_func('')

    #  Function called with non-existent path
    def test_nonexistent_path(self):
        @check_path
        def dummy_func(path):
            return True

        with pytest.raises(FileNotFoundError):
            dummy_func('/path/to/nonexistent')

class TestCheckLimits:

    #  The function receives an image with all values equal to the upper limit and returns the same image.
    def test_all_values_equal_to_upper_limit_returns_same_image(self):
        # Arrange
        image = np.array([[1, 1], [1, 1]], dtype='float32')

        @check_limits
        def dummy_func(image):
            return image

        # Act
        result = dummy_func(image)

        # Assert
        assert np.array_equal(result, image)

    #  The function receives an image with all values equal to the lower limit and returns the same image.
    def test_all_values_equal_to_lower_limit_returns_same_image(self):
        # Arrange
        image = np.array([[0, 0], [0, 0]], dtype='float32')

        @check_limits
        def dummy_func(image):
            return image

        # Act
        result = dummy_func(image)

        # Assert
        assert np.array_equal(result, image)

    #  The function receives an empty image and returns an empty image.
    def test_empty_image_returns_empty_image(self):
        # Arrange
        image = np.array([], dtype='float32')

        @check_limits
        def dummy_func(image):
            return image

        # Act
        result = dummy_func(image)

        # Assert
        assert np.array_equal(result, image)

    #  The function receives an image with a single value and returns the same image.
    def test_single_value_image_returns_same_image(self):
        # Arrange
        image = np.array([100], dtype='float32')

        @check_limits
        def dummy_func(image):
            return image

        # Act
        result = dummy_func(image)

        # Assert
        assert np.array_equal(result, [1.])

    #  The function receives an image with negative values and returns the clipped image.
    def test_negative_values_returns_clipped_image(self):
        # Arrange
        image = np.array([[-100, -200], [150, 250]], dtype='float32')

        @check_limits
        def dummy_func(image):
            return image

        # Act
        result = dummy_func(image)

        # Assert
        assert np.array_equal(result, np.array([[0., 0.], [1., 1.]], dtype='float32'))

    #  The function receives an image with values above the upper limit and returns the clipped image.
    def test_values_above_upper_limit_returns_clipped_image(self):
        # Arrange
        image = np.array([[300, 400], [500, 600]], dtype='float32')

        @check_limits
        def dummy_func(image):
            return image

        # Act
        result = dummy_func(image)

        # Assert
        assert np.array_equal(result, np.array([[1, 1], [1, 1]], dtype='float32'))


class TestAddMethod:

    #  The decorator function should return a function.
    def test_decorator_returns_function(self):

        class MyClass:
            pass

        @add_method(MyClass)
        def my_method():
            return None

        assert callable(MyClass.my_method)
