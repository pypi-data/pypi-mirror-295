# Copyright (c) 2024 Hansae Ju
# Licensed under the Apache License, Version 2.0
# See the LICENSE file in the project root for license terms.

import numpy as np

from javalang.tree import (
    MethodInvocation,
    SuperMethodInvocation,
    SuperConstructorInvocation,
    ExplicitConstructorInvocation,
)

from neurojit.cuf.halstead import halstead
from neurojit.cuf.cfg import CFG, use_def_graph
from neurojit.commit import Method, MethodChangesCommit
from neurojit.cuf.rii import incorrect_indentation_ratio


class MethodUnderstandabilityFeatures:
    """
    Class to compute understandability metrics for a single method.
    """

    def __init__(
        self,
        method: Method,
        commit_hash: str,
        checkstyle_path: str,
        xml_path: str,
        checkstyle_cache_dir: str,
    ) -> None:
        self.method = method
        self.cfg = CFG(self.method)
        self.cfg.compute_reaching_definitions()
        self.halstead = halstead(self.method)
        self.commit_hash = commit_hash
        self.checkstyle_path = checkstyle_path
        self.xml_path = xml_path
        self.checkstyle_cache_dir = checkstyle_cache_dir

    @property
    def HV(self):
        """
        HalsteadVolume (HV): The number of data components in code segment.
        """
        return self.halstead["volume"]

    @property
    def TE(self):
        """
        TermEntropy (TE): The relative distribution of unique terms in the source code (i.e., keywords, identifiers, and operators). TE increases with the uniform distribution of terms, but decreases when specific terms dominate.
        """
        tokens = [token.value for token in self.method.tokens]
        unique_tokens = set(tokens)
        token_count = len(tokens)
        token_entropy = 0
        for token in unique_tokens:
            token_probability = tokens.count(token) / token_count
            token_entropy += token_probability * np.log2(token_probability)
        token_entropy *= -1
        return token_entropy

    @property
    def DD(self):
        """
        DepDegree (DD): The degree of low-level dependencies between program operations in a use-def graph generated by the reaching definitions of variables. DD reflects how much developers need to track information flow.
        """
        return use_def_graph(self.cfg).depdegree

    @property
    def DD_HV(self):
        """
        DD/HV: The ratio of DepDegree to HalsteadVolume.
        """
        return self.DD / self.HV

    @property
    def MDNL(self):
        """
        MaxDepthNestingLoop (MDNL): The max depth of nesting loop.
        """
        return self.cfg.MDNL

    @property
    def NB(self):
        """
        NonStructuredBranch (NB): The number of non-structured branch statements (i.e., break and continue).
        """
        return self.cfg.NB

    @property
    def EC(self):
        """
        ExternalCall (EC): The number of external calls (i.e., APIs and library calls).
        """
        called_methods = set()
        local_methods = set()
        for _, node in self.method.ast:
            if isinstance(node, MethodInvocation):
                if node.qualifier:
                    called_methods.add(f"{node.qualifier}.{node.member}")
                else:
                    local_methods.add(node.member)
            elif isinstance(node, SuperConstructorInvocation):
                called_methods.add("super")
            elif isinstance(node, SuperMethodInvocation):
                called_methods.add(f"super.{node.member}")
            elif isinstance(node, ExplicitConstructorInvocation):
                local_methods.add("this")
        total = len(local_methods) + len(called_methods)
        if total == 0:
            return 0
        return len(called_methods) / total

    @property
    def NOP(self):
        """
        NumberOfParameters (NOP): The number of parameters.
        """
        return len(self.method.ast.parameters)

    @property
    def NOGV(self):
        """
        NumberOfGlobalVariables (NOGV): The number of global variables.
        """
        return (
            (len(self.cfg.global_variables) / len(self.cfg.variables))
            if len(self.cfg.variables) > 0
            else 0
        )

    @property
    def NOMT(self):
        """
        NumberOfMostTerms (NOMT): The number of terms in the line with the most terms.
        """
        tokens = [token for token in self.method.tokens]
        tokens_per_line = {}
        for token in tokens:
            if token.position.line not in tokens_per_line:
                tokens_per_line[token.position.line] = []
            tokens_per_line[token.position.line].append(token)
        terms_per_line = np.max([len(tokens) for tokens in tokens_per_line.values()])
        return terms_per_line

    @property
    def II(self):
        """
        IncorrectIndentations (II): The number of warnings for incorrect indentations examined by Checkstyle.
        """
        return incorrect_indentation_ratio(
            self.method,
            self.commit_hash,
            cache_dir=self.checkstyle_cache_dir,
            checkstyle_path=self.checkstyle_path,
            xml_path=self.xml_path,
        )


class CommitUnderstandabilityFeatures:
    """
    Class to compute understandability metrics for a commit.
    """

    def __init__(
        self,
        commit: MethodChangesCommit,
        checkstyle_path="checkstyle.jar",
        xml_path="indentation_config.xml",
        checkstyle_cache_dir="data/cache/checkstyle",
        by="mean",
    ) -> None:
        self.commit = commit
        self.by = by

        self.method_metrics = [
            MethodUnderstandabilityFeatures(
                method,
                commit.commit_hash,
                checkstyle_path,
                xml_path,
                checkstyle_cache_dir,
            )
            for method in self.commit.methods_after
        ]

    def set_paths(
        self,
        checkstyle_path="checkstyle.jar",
        xml_path="indentation_config.xml",
        checkstyle_cache_dir="data/cache/checkstyle",
    ):
        for metric in self.method_metrics:
            metric.checkstyle_path = checkstyle_path
            metric.xml_path = xml_path
            metric.checkstyle_cache_dir = checkstyle_cache_dir

    def _aggregate(self, metric: str):
        values = [getattr(method, metric) for method in self.method_metrics]
        if self.by == "max":
            return max(values)
        elif self.by == "min":
            return min(values)
        elif self.by == "mean":
            return np.mean(values)
        elif self.by == "median":
            return np.median(values)
        elif self.by == "sum":
            return sum(values)
        else:
            raise ValueError(f"Invalid aggregation method: {self.by}")

    @property
    def all(self):
        return {
            "HV": self.HV,
            "TE": self.TE,
            "DD": self.DD,
            "DD_HV": self.DD_HV,
            "MDNL": self.MDNL,
            "NB": self.NB,
            "EC": self.EC,
            "NOP": self.NOP,
            "NOGV": self.NOGV,
            "NOMT": self.NOMT,
            "II": self.II,
        }

    @property
    def HV(self):
        return self._aggregate("HV")

    @property
    def TE(self):
        return self._aggregate("TE")

    @property
    def DD(self):
        return self._aggregate("DD")

    @property
    def DD_HV(self):
        return self._aggregate("DD_HV")

    @property
    def MDNL(self):
        return self._aggregate("MDNL")

    @property
    def NB(self):
        return self._aggregate("NB")

    @property
    def EC(self):
        return self._aggregate("EC")

    @property
    def NOP(self):
        return self._aggregate("NOP")

    @property
    def NOGV(self):
        return self._aggregate("NOGV")

    @property
    def NOMT(self):
        return self._aggregate("NOMT")

    @property
    def II(self):
        return self._aggregate("II")
