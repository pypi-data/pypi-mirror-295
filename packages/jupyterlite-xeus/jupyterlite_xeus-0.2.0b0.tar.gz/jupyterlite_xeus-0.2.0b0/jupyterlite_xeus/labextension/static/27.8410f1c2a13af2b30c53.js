"use strict";(self.webpackChunk_jupyterlite_xeus=self.webpackChunk_jupyterlite_xeus||[]).push([[27],{27:(e,s,t)=>{t.r(s),t.d(s,{default:()=>g});var r=t(473),i=t(671),n=t(232),o=t(257),a=t(115),l=t.n(a),d=t(721),c=t(602),h=t(262);class _{constructor(e){this._contentsProcessor=void 0,this._isDisposed=!1,this._disposed=new c.Signal(this),this._executeDelegate=new h.PromiseDelegate,this._parentHeader=void 0,this._parent=void 0,this._ready=new h.PromiseDelegate;const{id:s,name:t,sendMessage:r,location:i,kernelSpec:n,contentsManager:o}=e;this._id=s,this._name=t,this._location=i,this._kernelSpec=n,this._contentsManager=o,this._sendMessage=r,this._worker=this.initWorker(e),this._remoteKernel=this.initRemote(e),this.initFileSystem(e)}initWorker(e){return crossOriginIsolated?new Worker(new URL(t.p+t.u(873),t.b),{type:void 0}):new Worker(new URL(t.p+t.u(950),t.b),{type:void 0})}initRemote(e){let s;return crossOriginIsolated?(this._worker.onmessage=this._processCoincidentWorkerMessage.bind(this),s=l()(this._worker),s.processDriveRequest=async e=>{if(!n.DriveContentsProcessor)throw new Error("File system calls over Atomics.wait is only supported with jupyterlite>=0.4.0a3");return void 0===this._contentsProcessor&&(this._contentsProcessor=new n.DriveContentsProcessor({contentsManager:this._contentsManager})),await this._contentsProcessor.processDriveRequest(e)}):(this._worker.onmessage=e=>{this._processComlinkWorkerMessage(e.data)},s=(0,d.wrap)(this._worker)),s.initialize({kernelSpec:this._kernelSpec,baseUrl:r.PageConfig.getBaseUrl(),mountDrive:e.mountDrive}).then(this._ready.resolve.bind(this._ready)),s}async handleMessage(e){this._parent=e,this._parentHeader=e.header,await this._sendMessageToWorker(e)}async _sendMessageToWorker(e){if("input_reply"!==e.header.msg_type&&(this._executeDelegate=new h.PromiseDelegate),await this._remoteKernel.processMessage({msg:e,parent:this.parent}),"input_reply"!==e.header.msg_type)return await this._executeDelegate.promise}get parentHeader(){return this._parentHeader}get parent(){return this._parent}get location(){return this._location}_processCoincidentWorkerMessage(e){var s,t,r,i,n;(null===(s=e.data)||void 0===s?void 0:s.header)&&(e.data.header.session=null!==(r=null===(t=this._parentHeader)||void 0===t?void 0:t.session)&&void 0!==r?r:"",e.data.session=null!==(n=null===(i=this._parentHeader)||void 0===i?void 0:i.session)&&void 0!==n?n:"",this._sendMessage(e.data),"status"===e.data.header.msg_type&&"idle"===e.data.content.execution_state&&this._executeDelegate.resolve())}_processComlinkWorkerMessage(e){var s,t,r,i;e.header&&(e.header.session=null!==(t=null===(s=this._parentHeader)||void 0===s?void 0:s.session)&&void 0!==t?t:"",e.session=null!==(i=null===(r=this._parentHeader)||void 0===r?void 0:r.session)&&void 0!==i?i:"",this._sendMessage(e),"status"===e.header.msg_type&&"idle"===e.content.execution_state&&this._executeDelegate.resolve())}get ready(){return this._ready.promise}get isDisposed(){return this._isDisposed}get disposed(){return this._disposed}dispose(){this.isDisposed||(this._worker.terminate(),this._worker=null,this._remoteKernel=null,this._isDisposed=!0,this._disposed.emit(void 0))}get id(){return this._id}get name(){return this._name}async initFileSystem(e){let s,t;if(e.location.includes(":")){const r=e.location.split(":");s=r[0],t=r[1]}else s="",t=e.location;await this._remoteKernel.ready(),await this._remoteKernel.mount(s,"/drive",r.PageConfig.getBaseUrl()),await this._remoteKernel.isDir("/files")?await this._remoteKernel.cd("/files"):await this._remoteKernel.cd(t)}}function u(e){const s=r.URLExt.join(r.PageConfig.getBaseUrl(),e),t=new XMLHttpRequest;return t.open("GET",s,!1),t.send(null),JSON.parse(t.responseText)}let p=[];try{p=u("xeus/kernels.json")}catch(e){throw console.log(`Could not fetch xeus/kernels.json: ${e}`),e}const g=p.map((e=>({id:`@jupyterlite/xeus-${e}:register`,autoStart:!0,requires:[o.IKernelSpecs],optional:[i.IServiceWorkerManager,n.IBroadcastChannelWrapper],activate:(s,t,i,n)=>{const o=u("xeus/kernels/"+e+"/kernel.json");o.name=e,o.dir=e;for(const[e,s]of Object.entries(o.resources))o.resources[e]=r.URLExt.join(r.PageConfig.getBaseUrl(),s);const a=s.serviceManager.contents;t.register({spec:o,create:async e=>{const s=!!((null==i?void 0:i.enabled)&&(null==n?void 0:n.enabled)||crossOriginIsolated);return s?console.info(`${o.name} contents will be synced with Jupyter Contents`):console.warn(`${o.name} contents will NOT be synced with Jupyter Contents`),new _({...e,contentsManager:a,mountDrive:s,kernelSpec:o})}})}})))}}]);