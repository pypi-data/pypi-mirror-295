"""Implementation of attrs and :mod:`dataclasses` fields and methods.

This is a transitional module for those who want to write code that works across
versions of this library.
"""

from __future__ import annotations

import collections
import contextlib
import typing
import warnings
from typing import TypeVar


from binobj._compat import dataclass_transform
from binobj import errors
from binobj.structures import initialize_struct_class
from binobj.structures import HasStruct
from binobj.structures import MutableStructMappingProxy
from binobj.typedefs import StrDict


if typing.TYPE_CHECKING:  # pragma: no cover
    from typing import Any
    from typing import Optional

    from binobj.fields.base import Field


TClass = TypeVar("TClass", bound=type)


def fields(struct: HasStruct) -> list[Field[Any]]:
    """Return a list of all the fields in the struct."""
    return sorted(struct.__binobj_struct__.components.values(), key=lambda f: f.index)


def asdict(struct: HasStruct) -> dict[str, Any]:
    """Convert the given struct to a dict."""
    return {f.name: getattr(struct, f.name) for f in fields(struct)}


def astuple(struct: HasStruct, *, tuple_factory=tuple) -> tuple[Any, ...]:
    """Convert the struct into a tuple, with fields in the order they're declared in.

    Fields that aren't set will use their default value.
    """
    return tuple_factory(getattr(struct, f.name) for f in fields(struct))


@dataclass_transform()
def struct(cls:TClass)->TClass:
    initialize_struct_class(cls)
    return cls

########################################################################################
# Former method implementations


def _to_dict_whatever_possible(self) -> dict[str, Any]:
    """Convert this struct to a dict, ignoring serialization-related errors.

    We use this to get values for all computed fields as well as any fields that have no
    dependencies and can serialize themselves (e.g. Bytes and sized int fields). This
    allows us to resolve forward references.
    """
    dct = {}

    # Try dumping all the fields we can first.
    for field in self.__binobj_struct__.components.values():
        try:
            dct[field.name] = field.compute_value_for_dump(
                typing.cast(StrDict, self)
            )
        except (errors.SerializationError, errors.UndefinedSizeError):  # noqa: PERF203
            pass
        except errors.Error as err:  # pragma: nocover
            warnings.warn(
                f"Ignored exception {err.__module__}.{type(err).__qualname__} while"
                " converting a struct to a dict. This type of exception may not be"
                " ignored in the future, as the original code was too broad. If you"
                " believe this type should still be caught, please file a bug"
                f" report.\n Original message: {err!r}",
                DeprecationWarning,
                stacklevel=2,
            )

    return dict(collections.ChainMap(dct, MutableStructMappingProxy(self)))



def get_struct_size(thing: HasStruct) -> Optional[int]:
    """Return the size of this struct in bytes, if possible.

    If there are variable-sized fields that can't be resolved, this function returns
    ``None`` instead. To get the size of an instance, prefer ``len(instance)``, as this
    can handle variable-sized fields.

    :return: The struct's size, in bytes.
    :rtype: int

    .. versionadded:: 0.3.0

    .. versionchanged:: 0.12.0
        This falls back to ``len()`` if `thing` is a Struct instance.
    """
    field_objects = thing.__binobj_struct__.components.values()
    with contextlib.suppress(errors.UndefinedSizeError, errors.MissingRequiredValueError):
        return sum(f.get_expected_size({}) for f in field_objects)

    size = 0
    current_fields = thing._to_dict_whatever_possible()

    for field in thing.__binobj_struct__.components.values():
        if field.has_fixed_size:
            size += typing.cast(int, field.size)
        else:
            try:
                size += field.get_expected_size(current_fields)
            except (errors.UndefinedSizeError, errors.MissingRequiredValueError):
                field_value = field.compute_value_for_dump(current_fields)
                size += len(field.to_bytes(field_value))

    return size
