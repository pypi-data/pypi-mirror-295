# coding: utf-8

"""
    Zuora API Reference

    REST API reference for the Zuora Billing, Payments, and Central Platform! Check out the [REST API Overview](https://www.zuora.com/developer/api-references/api/overview/).

    The version of the OpenAPI document: 2024-05-20
    Contact: docs@zuora.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from zuora_sdk.models.ramp_charge_request import RampChargeRequest
from zuora_sdk.models.ramp_interval_request import RampIntervalRequest
from typing import Optional, Set
from typing_extensions import Self

class CreateRamp(BaseModel):
    """
    Container of the ramp definitions. It is used to create, update, or remove the ramp definition for the new subscription. 
    """ # noqa: E501
    charges: Optional[List[RampChargeRequest]] = Field(default=None, description="Container for the rate plan charges that are considered as part of the ramp deal.  * If this field is not specified, all the one-time and recurring regular charges of the new subscription are automatically considered as part of the ramp deal. * If this field is specified, either 'chargeNumber' or 'uniqueToken' must be specified. ")
    delete: Optional[StrictBool] = Field(default=None, description="Whether to remove the ramp definition from the new subscription. If you want to remove the ramp definition, this field is the only required field for the `ramp` object.   ")
    description: Optional[StrictStr] = Field(default=None, description="The short description of the ramp.")
    intervals: Optional[List[RampIntervalRequest]] = Field(default=None, description="Container for the intervals that the ramp is split into in its timeline.   It is required when you want to create or update the ramp definition. The ramp intervals cannot have any overlap or gap between each other. ")
    name: Optional[StrictStr] = Field(default=None, description="The name of the ramp.")
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["charges", "delete", "description", "intervals", "name"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CreateRamp from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in charges (list)
        _items = []
        if self.charges:
            for _item_charges in self.charges:
                if _item_charges:
                    _items.append(_item_charges.to_dict())
            _dict['charges'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in intervals (list)
        _items = []
        if self.intervals:
            for _item_intervals in self.intervals:
                if _item_intervals:
                    _items.append(_item_intervals.to_dict())
            _dict['intervals'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CreateRamp from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "charges": [RampChargeRequest.from_dict(_item) for _item in obj["charges"]] if obj.get("charges") is not None else None,
            "delete": obj.get("delete"),
            "description": obj.get("description"),
            "intervals": [RampIntervalRequest.from_dict(_item) for _item in obj["intervals"]] if obj.get("intervals") is not None else None,
            "name": obj.get("name")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj


