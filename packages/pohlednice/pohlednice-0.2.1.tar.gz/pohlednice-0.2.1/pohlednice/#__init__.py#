from struct import Struct
from dataclasses import dataclass, fields
from enum import Enum as _Enum, auto as _auto

class VarInt:
    @classmethod
    def to_bytes(cls, value):
        while True:
            window = value & 0b111_1111
            value = value >> 7

            if value == 0:
                yield window
                break
            else:
                yield window | 0b1000_0000  
            
    @classmethod
    def from_bytes(cls, iterable):
        value = 0

        for index, byte in enumerate(iterable):
            value = (byte & ~0b1000_0000) << (index * 7) | value
            if not byte & 0b1000_0000:
                break

        return value

class U8:
    @classmethod
    def to_bytes(cls, value):
        yield value

    @classmethod
    def from_bytes(cls, iterable):
        return next(iterable)

class U16(VarInt):
    ...

class U32(VarInt):
    ...

class U64(VarInt):
    ...

class U128(VarInt):
    ...
    
class SignedVarInt(VarInt):
    @classmethod
    def to_bytes(cls, value):
        if value < 0:
            _value = ((-value - 1) << 1) | 1
        else:
            _value = value << 1
            
        yield from super().to_bytes(_value)

    @classmethod
    def from_bytes(cls, iterable):
        value = super().from_bytes(iterable)

        is_negative = value & 0x1

        value = value >> 1

        if is_negative:
            return -value - 1
        else:
            return value
            
        
class I8:
    @classmethod
    def to_bytes(cls, value):
        if value < 0:
            yield 0b1000_0000 | -value
        else:
            yield value

    @classmethod
    def from_bytes(cls, iterable):
        byte = next(iterable)
        value = (0b0111_1111 & byte)
        if (0b1000_0000 & byte):
            return -value
        else:
            return value

    
class I16(SignedVarInt):
    ...


class I32(SignedVarInt):
    ...


class I64(SignedVarInt):
    ...


class I128(SignedVarInt):
    ...


class __Float:
    @classmethod
    def to_bytes(cls, value):
        yield from iter(cls._format.pack(value))

    @classmethod
    def from_bytes(cls, iterable):
        buffer_ = b''

        for _ in range(cls._format.size):
            buffer_ += bytes(iterable)

        value, = cls._format.unpack(buffer_)
            
        return value

class F32(__Float):
    _format = Struct('f')

    
class F64(__Float):
    _format = Struct('d')

    
class Bool:
    @classmethod
    def to_bytes(cls, value):
        if value:
            yield 1
        else:
            yield 0

    @classmethod
    def from_bytes(cls, iterable):
        match byte := next(iterable):
            case 0:
                return False
            case 1:
                return True
            case _:
                raise ValueError(f'{byte} is not valid for bool type !')


class Option:
    @classmethod
    def derive(cls, type_):
        class SpecializedOption(cls):
            type = type_

        return SpecializedOption

    @classmethod
    def to_bytes(cls, value):
        if value is None:
            yield 0
        else:
            yield 1
            yield from cls.type.to_bytes(value)


    @classmethod
    def from_bytes(cls, iterable):
        if Bool.from_bytes(iterable):
            return cls.type.from_bytes(iterable)
        else:
            return None


class Tuple:
    @classmethod
    def derive(cls, *types_):
        class SpecializedTuple(cls):
            types = types_

        return SpecializedTuple

    @classmethod
    def to_bytes(cls, value):
        for type_, _value in zip(cls.types, value):
            yield from type_.to_bytes(_value)

    @classmethod
    def from_bytes(cls, iterable):
        return tuple(
            type_.from_bytes(iterable)
            for type_
            in cls.types
        )

@dataclass
class Struct:
    @classmethod
    def to_bytes(cls, value):
        for field in fields(cls):
            yield from field.type.to_bytes(getattr(value, field.name))

    @classmethod
    def from_bytes(cls, iterable):
        return cls(*(
            field.type.from_bytes(iterable)
            for field
            in fields(cls)
        ))

class List:
    @classmethod
    def derive(cls, type_):
        class SpecializedList(cls):
            type = type_

        return SpecializedList
    
    @classmethod
    def to_bytes(cls, value):
        yield from VarInt.to_bytes(len(value))
        
        for _value in value:
            yield from cls.type.to_bytes(_value)

    @classmethod
    def from_bytes(cls, iterable):
        length = VarInt.from_bytes(iterable)

        return [cls.type.from_bytes(iterable)
                for _
                in range(length)]


class ByteArray(List):
    type = U8


class String(ByteArray):
    @classmethod
    def to_bytes(cls, value):
        yield from super().to_bytes(value.encode('utf-8'))

    @classmethod
    def from_bytes(cls, iterable):
        return bytes(super().from_bytes(iterable)).decode('utf-8') 
    

class Dict:
    @classmethod
    def derive(cls, key_, value_):
        class SpecializedDict(cls):
            key = key_
            value = value_

        return SpecializedDict

    @classmethod
    def __type(cls):
        class Item(Tuple):
            types = (cls.key, cls.value)

        class Items(List):
            type = Item

        return Items
    
    @classmethod
    def to_bytes(cls, value):
        yield from cls.__type().to_bytes(list(value.items()))

    @classmethod
    def from_bytes(cls, iterable):
        return dict(cls.__type().from_bytes(iterable))


class Enum(_Enum):
    @classmethod
    def to_bytes(cls, value):
        if isinstance(value, cls):
            if isinstance(value.value, tuple):
                raise ValueError(f'{value} is a typed variant of {cls}')
            yield from VarInt.to_bytes(value.value - 1)
        else:
            for member in cls:
                if not isinstance(member.value, tuple):
                    continue

                index, kind = member.value

                if match(value, kind):
                    yield from VarInt.to_bytes(index - 1)
                    yield from kind.to_bytes(value)
                    break
            else:
                raise ValueError(f'Neither non-typed nor typed variant matched for {cls}')
            
    @classmethod
    def from_bytes(cls, iterable):
        index = VarInt.from_bytes(iterable)
        member = list(iter(cls))[index]
        
        if not isinstance(member.value, tuple):
            return member

        _, kind = member.value
        return kind.from_bytes(iterable)

    @staticmethod
    def _generate_next_value_(name, start, count, last_values):
return type(name, (Variant,), {'index': count + 1, 'type': None})

class Variant:
    index = None
    type = None
    
    def __init__(self, value):
        self.value = value
        
def match(value, kind):
    if isinstance(value, bool) and kind == Bool:
        return True
    elif isinstance(value, str) and kind == String:
        return True
    elif issubclass(kind, Struct) and isinstance(value, kind):
        return True
    elif issubclass(kind, Option):
        if value is None:
            return True
        else:
            return match(value, Option.type)
    elif isinstance(value, int):
        if (value >= 0
            and (kind == U8
                 or issubclass(kind, VarInt)
                 or issubclass(kind, SignedVarInt))):
            return True
        elif (value < 0
              and (kind == I8
                   or issubclass(kind, SignedVarInt))):
            return True        
    elif isinstance(value, tuple) and issubclass(kind, Tuple):
        return (len(value) == len(kind.types) and
                all(match(member, Member)
                    for member, Member
                    in zip(value, kind.types)))
    elif isinstance(value, (tuple, list)) and issubclass(kind, List):
        return all(match(member, kind.type) for member in value)
    elif isinstance(value, dict) and issubclass(kind, Dict):
        return all(match(key, kind.key) or match(value, kind.value)
                   for key, value
                   in value.items())
    return False
